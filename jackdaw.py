# Copyright Jeremy Chin, 2025.
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Uses code from https://github.com/user202729/plover-jackdaw-alt1 , hence the GPLv3.

try:
    from typing import Optional, Tuple, Union
except ImportError:
    pass
from micropython import const

import kmk.handlers.stock as handlers
from kmk.keys import Key, KC, make_key, ModifierKey
from kmk.kmk_keyboard import KMKKeyboard
from kmk.modules import Module
from kmk.utils import Debug
from supervisor import ticks_ms

from dvp import DVP
DVP = DVP()

# Block will be used for L/Vowels/R/special
class JackdawKey(Key):
    def __init__(self, code, block):
        self.code = code
        self.block = block
        super().__init__()

class OutputStroke():
    def __init__(self, keycode, end_sentence = False, attach_left = False, attach_right = False, ignore_shift = True):
        self.keycode = keycode
        self.end_sentence = end_sentence
        self.attach_left = attach_left
        self.attach_right = attach_right
        self.ignore_shift = ignore_shift

# JD_4 is an A key
# This is in steno order!

lh_keycodes = [
# Not LH but needs to be up first
'F', # Function?

'4',
'S',
'C',
'T',
'W',
'H',
'N',
'R',
'X',
'Z',
]

center_keycodes = [
'UO', # Because this is a modifier
'A',
'O',
'E',
'u',
]

rh_keycodes =  [
'x', # These are maybe special
'z',

'xQUOTE',

'r',
'n',
'l',
'g',
'c',
'h',
't',
's',

'dE', # Call this something else, the t breaks shit (generates Y or TE)
'e',
'y',

'xDOT',
'xCOMMA',
]

special_keycodes = [
'BS',
'SHIFT',
]

jd_keycodes = lh_keycodes + center_keycodes + rh_keycodes + special_keycodes
for key in jd_keycodes:
    make_key(names = ("JD_" + key,), constructor = JackdawKey, code = key, block = 0)

""" Vowel silliness
AO - EU is reasonable...
    That's the steno order
    The patent order is ei-a-ou
A
O
E
U
ao
ae
au
oe
ou
eu

aoe
aou
aeu
oeu

aoeu

SO the existent 2-chars are:
aa
ae*
ai*
ao*
au*

ea**
ee**
ei**
eo
eu*

ia* trial
ie** field
ii
io** prior
iu?

oa* boar
oe?
oi* toil
oo**
ou**

ua
ue* fuel
ui?
uo 
uu
at least 16 combinations in use

I don't recall whose dataset this is, extracted from an English bigram frequency chart
    "ou": 17457, <-- natural
    "ea": 13361, <-- natural (kind of, flip of ae)
    "io": 12278, <-- generated by AO
    "ee": 7446,
    "ai": 6880,
    "ie": 6832, <-- generated by OE
    "oo": 4910,
    "ia": 4867, <-- generated with flip ai
    "ei": 3441, <-- flip
    "ue": 2439, <-- U combo
    "ua": 2205, <-- U combo
    "au": 2136, <-- natural
    "ui": 1974, <-- U combo
    "oi": 1837, <-- present

    "oa": 1692, <-- less than 10% (I added it in...)
    "eo": 1497, <-- not available (use for "people", can't think of much else)
    "oe": 734, <-- shifted EU
    "eu": 340, <-- missing
    "ae": 266, <-- missing
    "iu": 221, <-- missing

    "uo": 150, < -- less than 1% (generates by U combo)
    "ao": 75,
    "ii": 57,
    "aa": 53,
    "uu": 11,
"""

# One thing to try: UO alone and the alternate to generate more vowel pairs
# and both together?
rules_vowels_raw = {
        # E is right-hand, it's uppercased so it doesn't conflict with far-right e
        # AO-eu
        'AEu': 'ai',
        'Au': 'au',
        'AE': 'ea',
        'AOE': 'ee',
        'Eu': 'i',
        'OE': 'ie',
        'AO': 'io',
        'OEu': 'oi',
        'AOu': 'oo',
        'Ou': 'ou',
        'AOEu': 'oa',

        'A': 'a',
        'O': 'o',
        'E': 'e',
        'u': 'u',

        }
# With this I can get virtually full coverage of the vowel bigram space!
# 15 combos * 2
# The 6 combos that only use one hand are premium space
# AU is quite annoying to reach
rules_vowels_shifted_raw = {
        'A': 'ua',
        'O': 'uo', # Kind of useless, virtually no cases that aren't quo
        'E': 'ue',
        'u': 'ui', # uu makes no sense
        'Eu': 'oe', # not great (confusing), but generating a single is a bit useless
        'AO': 'eo',
        'Ou': 'ui', # Redundant

        'OE': 'ei', # regular flip
        'AE': 'ae', # regular flip

        'AEu': 'ia', # regular flip

        'AOE': 'ee', # redundant (in main layer)
        'OEu': 'iou',
        'AOu': 'oo', # redundant

        'AOEu': '', # painful
        'Au': '', # Even more painful
        # Can generate 3-letter sets too, might be more useful. eau, in particular?
        # iou appears a little bit (curious). Actually more than eau!
        # Want: iu (medium) but it's pretty low frequency
        # eo? (people... anything else?)
        }

# Pre-generated out of jackdaw_map.rb to save memory
from jackdaw_rules import rules

# Extended rules that I don't want in the generator. Must be sorted by length.
# Probably throw these away
rules['x'] = [('xCOMMA', ','), ('xQUOTE', '\''), ('xDOT', '.'), ('x', '')]
# ===================
# Also want key-emitting stuff to I can lose the special cases

# Numbers... making it shiftable gives me symbols too, which is nice
# Is there any advantage to putting in here rather than switching to Cykey?
# Spacing rules is about the only thing
# breaks my flow too but ehhh
# Oh hey I need stuff like hash too

rules_vowels = {x: list() for x in center_keycodes}
for rule in rules_vowels_raw.items():
    rules_vowels[rule[0][0]].append(rule)
    
rules_vowels_shifted = {x: list() for x in center_keycodes}
for rule in rules_vowels_shifted_raw.items():
    rules_vowels_shifted[rule[0][0]].append(rule)

for v in center_keycodes:
    rules_vowels[v] = sorted(rules_vowels[v], key = lambda x: -len(x[0]))
    rules_vowels_shifted[v] = sorted(rules_vowels_shifted[v], key = lambda x: -len(x[0]))

# No reason to do the leader breakdown like the main generator
specials = {
    'xQUOTEOU': '"', # sub-optimal, probably

    'F': '',

    # Cykey layout uses the dropped pinkie just because I prefer it
    'FN': KC.N1, # Cykey style
    'FNO': KC.N2, # Cykey style
    'FWNO': KC.N3, # Cykey style
    'FCWNO': KC.N4, # Cykey style
    'F4CWNO': KC.N5, # Cykey style
    'F4': KC.N6, # Cykey style
    'F4C': KC.N7, # Cykey style
    'F4CW': KC.N8, # Cykey style
    'F4CWN': KC.N9, # Cykey style
    'FW': KC.N0, # Cykey style

    'FNUO': KC.LSFT(KC.N1), # Number + vowel mod for shifter numbers (symbols)
    'FNUOO': KC.LSFT(KC.N2),
    'FWNUOO': KC.LSFT(KC.N3),
    'FCWNUOO': KC.LSFT(KC.N4),
    'F4CWNUOO': KC.LSFT(KC.N5),
    'F4UO': KC.LSFT(KC.N6),
    'F4CUO': KC.LSFT(KC.N7),
    'F4CWUO': KC.LSFT(KC.N8),
    'F4CWNUO': KC.LSFT(KC.N9),
    'FWUO': KC.LSFT(KC.N0),
 
    # Better than the asterisk reach? But it's always in use anyway...
    'Hg': OutputStroke(KC.SPC, attach_left = True, attach_right = True),
    
    'F4CN': DVP['COMM'],
    'FCWN': DVP['DOT'],
    'FCWO': DVP['QUES'], # 
    'F4WN': DVP['EXLM'],

    'F4CNO': DVP['COLN'],
    'FCNO': DVP['SCLN'],
    'F4W': KC.LEFT_PAREN, # TODO: bind right (suppress space = set join flag)
    'FWO': KC.RIGHT_PAREN,
    'F4O': KC.QUOT, # DVp['MINUS'], # Don't know why this doesn't work via DV
    'FCW': KC.LSFT(KC.Q), # DOUBLE_QUOTE # TODO: bind right (suppress space)
    'F4WNO': DVP['QUOT'], # TODO: bind right (suppress space)
    # so... 

    'F4WO': DVP['EQL'],
    'FCO': DVP['BSLS'],
    'F4N': DVP['SLSH'],

    # Punctuation up to here should probably be top-layer
    # If I want this for coding all braces and things too
    # Right-hand modifier, left-hand symbol select?
    # RLCT is open... (generates rpt but that's kind of useless)

    # Stolen from Ardux

    'CTrlct': OutputStroke(DVP['EXLM'], attach_left = True, end_sentence = True),
    'TNrlct': OutputStroke(DVP['COMM'], attach_left = True, end_sentence = False),
    'HNrlct': OutputStroke(DVP['DOT'], attach_left = True, end_sentence = True),

    # TH for quote, add N or 4 to set which way it binds
    'THNrlct': OutputStroke(DVP['QUOT'], attach_left = True, attach_right = False), # Left single quote
    '4THrlct': OutputStroke(DVP['QUOT'], attach_left = False, attach_right = True), # Right single quote
    # Same for double quote (stacked NR/4S)
    'NRrlct': OutputStroke(KC.LSFT(DVP['QUOT']), attach_left = True, attach_right = False), # Left dquote
    '4Srlct': OutputStroke(KC.LSFT(DVP['QUOT']), attach_left = False, attach_right = True), # Right dquote
    # Apostrophe is STWN, without punctuation modifier (since it joins with other words)
    'SNrlct': DVP['SLSH'],

    # R +
    # ` ; \ 
    # = - ? R
    '4Rrlct': KC.GRV,
    'CRrlct': OutputStroke(DVP['SCLN'], attach_left = True),
    'WRrlct': DVP['BSLS'],

    'SRrlct': DVP['EQL'],
    'TRrlct': KC.QUOT, # Still weird (-)
    'HRrlct': OutputStroke(DVP['QUES'], attach_left = True, end_sentence = True),

    # N + (same as above, with shift held
    # ~ : | N
    # X X X  <-- Xs are regular punctuation instead
    '4Nrlct': KC.LSFT(KC.GRV),
    'CNrlct': OutputStroke(KC.LSFT(DVP['SCLN']), attach_left = True),
    'WNrlct': KC.LSFT(DVP['BSLS']),
    #'SNrlct': DVP['EQL'], # already shifted
    #'TNrlct': KC.LSFT(KC.QUOT), # Still weird (-) underscore needs to be moved somewhere...
    #'HNrlct': DVP['QUES'], # already shifted
    # Or don't?
    # TODO: hash and whatever?
    # Need to summarize what I actually need...

    # NR +
    # { ( ) N
    # } [ ] R
    '4NRrlct': DVP['SLSH'], # remainder NYI
    'CNRrlct': OutputStroke(KC.LEFT_PAREN, attach_right = True),
    'WNRrlct': OutputStroke(KC.RIGHT_PAREN, attach_left = True),
    'SNRrlct': DVP['SLSH'],
    'TNRrlct': DVP['SLSH'],
    'HNRrlct': DVP['SLSH'],
     # Need to put < > somewhere

     # Inversion - apostrophe + nt -> n't (otherwise it takes 2 strokes)
     'STWNnt': OutputStroke((DVP['N'], DVP['QUOT'], DVP['T']), attach_left = True, attach_right = False)
}

class ChordState():
    def __init__(self):
        self.auto_space = True

class RewindBuffer():
    BUFFER_SIZE = 10
    def __init__(self):
        self.buffer = [(1, False, False)] * self.BUFFER_SIZE
        self.buffer_write = 0
        self.reversed = 0 # For tracking single-char removals
    def add(self, chars, suppress_space, shift):
        self.buffer_write += 1
        self.buffer_write %= self.BUFFER_SIZE
        self.buffer[self.buffer_write] = (chars, suppress_space, shift)
    def backspace(self):
        # Return the entire state
        ret = self.buffer[self.buffer_write]
        self.buffer[self.buffer_write] = (1, False, False)
        self.buffer_write -= 1
        self.buffer_write %= self.BUFFER_SIZE
        return ret

class Chord():
    def __init__(self, compact, rgb, state):
        self.rgb = rgb
        self.compact = compact
        self.chord = {x: False for x in jd_keycodes}

        self.state = state
        self.rewind = RewindBuffer()

        # Things that flow into the next chord
        self.next_shift = False
        self.suppress_space = True

        #self.last_suppress_space = False
        #self.last_stroke = 1 # for backspacing
        #self.last_shift = False

    def set_rgb(self, mode):
        if not self.rgb:
            return
        if mode:
            print("set ON")
            self.rgb.set_hsv_fill(176, 140, 90)
        else:
            print("set OFF")
            self.rgb.set_hsv_fill(30, 200, 180)

        self.rgb.show()


    def reset(self):
        for x in self.chord:
            self.chord[x] = False

    def add(self, key):
        self.chord[key] = True
    def discard(self, key):
        self.chord[key] = False

    def result(self, auto_space_override = None):
        auto_space = self.state.auto_space
        if auto_space_override != None:
            auto_space = auto_space_override

        blocks = ["".join([c for c in keys if self.chord[c]]) for keys in (center_keycodes, lh_keycodes, rh_keycodes, special_keycodes)]
        combined = blocks[1] + blocks[0] + blocks[2] + blocks[3]

        if len(combined) == 0:
            return ""

        print("Chord: ", blocks)

        end_sentence = False
        attach_left = False
        attach_right = False
        end_sentence = False

        output = ""

        if combined == "S" and self.compact or combined == "BS" or combined == "SHIFT":
            keys, space, shift = self.rewind.backspace()
            result = [KC.BSPACE] * keys
            self.suppress_space = space
            self.next_shift = shift
            return result
        elif combined in ('x', 'X', 'z', 'Z'):
            self.last_stroke = 1
            self.suppress_space = True
            return [KC.SPC]
        elif combined == "rnghts": # -RNGHTS: Enter (-> no space)
            self.last_stroke = 1
            self.suppress_space = True
            return [KC.ENTER]
            # Maybe this could be marked as a special?
            # attach left, attach right
        elif combined == "STHR": # STHR-: Shift next char
            self.next_shift = True
            return []
        elif combined == "STHRrlct": # STHR-rlct: unshift next char
            self.next_shift = False
            return []
        elif combined == "WHNRrnlg": # WHNR-rnlg (inner 2x2s): Auto space toggle
            self.state.auto_space = not self.state.auto_space
            self.suppress_space = True
            self.set_rgb(not self.state.auto_space)
            return []
        elif combined == "SCTWHN": #SCTWHN: escape
            self.suppress_space = True
            return [KC.ESCAPE]
        elif combined == "SCTWHR": #SCTWHR: tab (the SB combos - SBN, SBR are useless)
            self.suppress_space = True
            return [KC.ESCAPE]
        elif combined == 'rlgcht':  # -rlgcht: Force-suppress next space
            # Normally generates rlft, useless
            # Could also just double-flip auto space
            self.suppress_space = True
            return []
        elif combined in specials:
            special = specials[combined]
            if isinstance(special, OutputStroke):
                end_sentence = special.end_sentence
                attach_left = special.attach_left
                attach_right = special.attach_right
                if special.ignore_shift:
                    self.next_shift = False

                special = specials[combined].keycode

            if isinstance(special, Key):
                output = [special]
            else:
                output = special
        else:
            # The regular chord generation rules
            generated = []
            output_v = []
            vowel_shift = blocks[0].startswith("UO")
            vrules = rules_vowels_shifted if vowel_shift else rules_vowels
            idx = 2 if vowel_shift else 0
            while idx < len(blocks[0]):
                initial_idx = idx
                if blocks[0][idx] not in vrules:
                    output_v += blocks[0][idx]
                    idx += 1
                    continue
                candidates = vrules[blocks[0][idx]]
                for c in candidates:
                    if blocks[0].startswith(c[0], idx):
                        output_v += list(c[1])
                        idx += len(c[0])
                        break

                # TODO: just to stop the vowels from breaking
                if idx == initial_idx:
                    output_v += blocks[0][idx]
                    idx += 1

            for block in range(1, 4):
                block_output = []
                idx = 0

                while idx < len(blocks[block]):

                    # single x is used for things
                    if blocks[block].startswith(('X', 'z', 'Z'), idx):
                        attach_left = True
                        idx += 1
                        continue
                    # TODO: scrap this, this is not how shift works any more
                    # But this is still backspace
                    if blocks[block].startswith('SHIFT', idx):
                        idx += 5 # len('shift')
                        # Now this does nothing, actually. Maybe it shuold generate an e?
                        break # not continue because SHIFT is at the end

                    initial_idx = idx

                    if blocks[block][idx] not in rules:
                        block_output += list(blocks[block][idx])
                        idx += 1
                        continue

                    candidates = rules[blocks[block][idx]]
                    for c in candidates:
                        if blocks[block].startswith(c[0], idx):
                            block_output += list(c[1])
                            idx += len(c[0])
                            break

                    # Guarantees no infinite loop
                    if idx == initial_idx:
                        block_output += list(blocks[block][idx])
                        idx += 1
                generated.append(block_output)

            output = generated[0] + output_v + generated[1] + generated[2]
            if len(output) == 0:
                return "" # There's a chord that generates nothing

            # Horrible hack: apostrophe force-attaches (don't want to put it in specials because there are too many RH combos)
            # NOTE: check blocks rather than output for generated auto-spacing, since the null (WHR) generates nothing and then it's empty
            if output[0] == "'" or len(blocks[1]) == 0:
                attach_left = True

        keystrokes = [c if isinstance(c, Key) else DVP[c] for c in output]

        if self.next_shift:
            keystrokes[0] = KC.LSFT(keystrokes[0])

        if not self.suppress_space and not attach_left and auto_space:
            keystrokes = [KC.SPC] + keystrokes

        self.rewind.add(len(keystrokes), self.suppress_space, self.next_shift)

        self.next_shift = end_sentence
        self.suppress_space = attach_right

        return keystrokes

## Compact mode: left S tapped alone is backspace
class Jackdaw(Module):
    #CHAINABLE = set(('X', 'Z', 'z', 'F'))
    CHAINABLE = set(('F',))
    def __init__(self, compact = False, rgb = None):
        self.state = ChordState()
        self.rgb = rgb
        self.chord = Chord(compact, rgb, self.state)
        self.compact = compact

        self.held = set()
        self.pressing = True # press/release edge

        # Stream the output
        self.send_next = []
        # Try to work around the tap_key weirdness
        self.now_pressed = None

    def process_key(self, keyboard, key, is_pressed, int_coord):

        if not isinstance(key, JackdawKey):
            return key

        # TODO: Can we detect modifiers? Want to force a mode switch to non-spaced if they're held
        # And then maybe a null modifier to unspace might be nice... (fingerspell key)

        code = key.code

        if is_pressed:
            self.held.add(code)
            self.chord.add(code)
            self.pressing = True
        else:
            self.held.discard(code)

            if self.state.auto_space:
                if self.held - self.CHAINABLE == set():
                    # coordkeys is private but ehhhh
                    modifiers_held = any([isinstance(key, ModifierKey) for key in keyboard._coordkeys_pressed.values()])

                    # No modifiers goes to True, which is consistent with auto_space a few lines up
                    output = self.chord.result(auto_space_override = not modifiers_held)
                    self.handle_output(output)
                    self.chord.reset()
                    for key in self.held:
                        if key in self.CHAINABLE:
                            self.chord.add(key)

                self.pressing = False
                # Nothing important to do on the transition to auto_space, probably
            else:
                if self.pressing:
                    output = self.chord.result()
                    self.handle_output(output)
                self.chord.discard(code)
                if self.state.auto_space:
                    # Transition happened in this frame
                    self.chord.reset()
                self.pressing = False


    # Not really chord, this is the output string
    def handle_output(self, chord):
        if chord == "":
            return
        out = [c for c in list(chord)]
        out.reverse()

        self.send_next += out

    def during_bootup(self, keyboard):
        # TODO: cleaner bootup chain
        #self.chord.set_rgb(False)
        pass

    def before_matrix_scan(self, keyboard):
        pass
    def after_matrix_scan(self, keyboard):
        pass

    def before_hid_send(self, keyboard):
        was_pressed = self.now_pressed 
        if self.now_pressed != None:
            keyboard.remove_key(self.now_pressed)
            self.now_pressed = None
        # up/down in the same frame is possible unless it's the same key
        if len(self.send_next) > 0 and self.send_next[-1] != was_pressed:
            key = self.send_next.pop()
            keyboard.add_key(key)
            self.now_pressed = key

    def after_hid_send(self, keyboard):
        pass

    def on_powersave_enable(self, keyboard):
        pass

    def on_powersave_disable(self, keyboard):
        pass

# In the end this is a lot closer to the original Shelton patent than the Jackdaw theory

# TODO:
# Matrix reset button
# Merge punctuation/number key into one word
#   on press -> emit space
#   at end of word -> re-enable auto space
# Backspace count buffer
#   single backspaces need to cleanly go through it, the word breaks should remain
# Split auto-space on/off (avoid toggles)

# GRRRRR the weird matrix desync:
# keydown is sending keyup!
# the pressed/released flag comes straight out of KMK
# So... KMK is flipping the flags somehow?
# But the source looked ok....
# It happens on one side of the board so it's not a comunication problem
# One-cycle delay makes me think the KMK event loop is not triggering properly, not running when idle...?
# The scanner runs in the background, is there a synchronization bug...?
# Maybe the default interval is better? Though 100hz is really the minimum here.... what happens at 0.001?
# Let's just leave it and see... 
# at 1khz it desyncs more!
# there's a 1ms delay in each _row_ built into circuitpython, it won't go that fast anyway. Bugger.

