# Copyright Jeremy Chin, 2025.
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Uses code from https://github.com/user202729/plover-jackdaw-alt1 , hence the GPLv3.

try:
    from typing import Optional, Tuple, Union
except ImportError:
    pass
from micropython import const

import kmk.handlers.stock as handlers
from kmk.keys import Key, KC, make_key
from kmk.kmk_keyboard import KMKKeyboard
from kmk.modules import Module
from kmk.utils import Debug
from supervisor import ticks_ms

from dvp import DVP
DVP = DVP()

# Block will be used for L/Vowels/R/special
class JackdawKey(Key):
    def __init__(self, code, block):
        self.code = code
        self.block = block
        super().__init__()

class OutputStroke():
    def __init__(self, keycode, end_sentence = False, attach_left = False, attach_right = False, ignore_shift = True):
        self.keycode = keycode
        self.end_sentence = end_sentence
        self.attach_left = attach_left
        self.attach_right = attach_right
        self.ignore_shift = ignore_shift

# JD_4 is an A key
# This is in steno order!

lh_keycodes = [
# Not LH but needs to be up first
'F', # Function?

'4',
'S',
'C',
'T',
'W',
'H',
'N',
'R',
'X',
'Z',
]

center_keycodes = [
'UO', # Because this is a modifier
'A',
'O',
'E',
'u',
]

rh_keycodes =  [
'x', # These are maybe special
'z',

'xQUOTE',

'r',
'n',
'l',
'g',
'c',
'h',
't',
's',

'dE', # Call this something else, the t breaks shit (generates Y or TE)
'e',
'y',

'xDOT',
'xCOMMA',
]

special_keycodes = [
'BS',
'SHIFT',
]

jd_keycodes = lh_keycodes + center_keycodes + rh_keycodes + special_keycodes
for key in jd_keycodes:
    make_key(names = ("JD_" + key,), constructor = JackdawKey, code = key, block = 0)

""" Vowel silliness
AO - EU is reasonable...
    That's the steno order
    The patent order is ei-a-ou
A
O
E
U
ao
ae
au
oe
ou
eu

aoe
aou
aeu
oeu

aoeu

SO the existent 2-chars are:
aa
ae*
ai*
ao*
au*

ea**
ee**
ei**
eo
eu*

ia* trial
ie** field
ii
io** prior
iu?

oa* boar
oe?
oi* toil
oo**
ou**

ua
ue* fuel
ui?
uo 
uu
at least 16 combinations in use

I don't recall whose dataset this is, extracted from an English bigram frequency chart
    "ou": 17457, <-- natural
    "ea": 13361, <-- natural (kind of, flip of ae)
    "io": 12278, <-- generated by AO
    "ee": 7446,
    "ai": 6880,
    "ie": 6832, <-- generated by OE
    "oo": 4910,
    "ia": 4867, <-- generated with flip ai
    "ei": 3441, <-- flip
    "ue": 2439, <-- U combo
    "ua": 2205, <-- U combo
    "au": 2136, <-- natural
    "ui": 1974, <-- U combo
    "oi": 1837, <-- present

    "oa": 1692, <-- less than 10% (I added it in...)
    "eo": 1497, <-- not available (use for "people", can't think of much else)
    "oe": 734, <-- shifted EU
    "eu": 340, <-- missing
    "ae": 266, <-- missing
    "iu": 221, <-- missing

    "uo": 150, < -- less than 1% (generates by U combo)
    "ao": 75,
    "ii": 57,
    "aa": 53,
    "uu": 11,
"""

# One thing to try: UO alone and the alternate to generate more vowel pairs
# and both together?
rules_vowels_raw = {
        # E is right-hand, it's uppercased so it doesn't conflict with far-right e
        # AO-eu
        'AEu': 'ai',
        'Au': 'au',
        'AE': 'ea',
        'AOE': 'ee',
        'Eu': 'i',
        'OE': 'ie',
        'AO': 'io',
        'OEu': 'oi',
        'AOu': 'oo',
        'Ou': 'ou',
        'AOEu': 'oa',

        'A': 'a',
        'O': 'o',
        'E': 'e',
        'u': 'u',

        }
# With this I can get virtually full coverage of the vowel bigram space!
# 15 combos * 2
# The 6 combos that only use one hand are premium space
# AU is quite annoying to reach
rules_vowels_shifted_raw = {
        'A': 'ua',
        'O': 'uo', # Kind of useless, virtually no cases that aren't quo
        'E': 'ue',
        'u': 'ui', # uu makes no sense
        'Eu': 'oe', # not great (confusing), but generating a single is a bit useless
        'AO': 'eo',
        'Ou': 'ui', # Redundant

        'OE': 'ei', # regular flip
        'AE': 'ae', # regular flip

        'AEu': 'ia', # regular flip

        'AOE': 'ee', # redundant (in main layer)
        'OEu': 'iou',
        'AOu': 'oo', # redundant

        'AOEu': '', # painful
        'Au': '', # Even more painful
        # Can generate 3-letter sets too, might be more useful. eau, in particular?
        # iou appears a little bit (curious). Actually more than eau!
        # Want: iu (medium) but it's pretty low frequency
        # eo? (people... anything else?)
        }

# Pre-generated out of jackdaw_map.rb to save memory
from jackdaw_rules import rules

# Extended rules that I don't want in the generator. Must be sorted by length.
# Probably throw these away
rules['x'] = [('xCOMMA', ','), ('xQUOTE', '\''), ('xDOT', '.'), ('x', '')]
# ===================
# Also want key-emitting stuff to I can lose the special cases

# Numbers... making it shiftable gives me symbols too, which is nice
# Is there any advantage to putting in here rather than switching to Cykey?
# Spacing rules is about the only thing
# breaks my flow too but ehhh
# Oh hey I need stuff like hash too

rules_vowels = {x: list() for x in center_keycodes}
for rule in rules_vowels_raw.items():
    rules_vowels[rule[0][0]].append(rule)
    
rules_vowels_shifted = {x: list() for x in center_keycodes}
for rule in rules_vowels_shifted_raw.items():
    rules_vowels_shifted[rule[0][0]].append(rule)

for v in center_keycodes:
    rules_vowels[v] = sorted(rules_vowels[v], key = lambda x: -len(x[0]))
    rules_vowels_shifted[v] = sorted(rules_vowels_shifted[v], key = lambda x: -len(x[0]))

# No reason to do the leader breakdown like the main generator
specials = {
    'Es': OutputStroke('es', attach_left = True),
    'Eung': OutputStroke('ing', attach_left = True),
    'Enlg': OutputStroke('ed', attach_left = True),
    'Er': OutputStroke('er', attach_left = True), # Not sure about this one
    'xQUOTEOU': '"', # sub-optimal, probably

    'F': '',

    # Cykey layout uses the dropped pinkie just because I prefer it
    'FN': KC.N1, # Cykey style
    'FNO': KC.N2, # Cykey style
    'FWNO': KC.N3, # Cykey style
    'FCWNO': KC.N4, # Cykey style
    'F4CWNO': KC.N5, # Cykey style
    'F4': KC.N6, # Cykey style
    'F4C': KC.N7, # Cykey style
    'F4CW': KC.N8, # Cykey style
    'F4CWN': KC.N9, # Cykey style
    'FW': KC.N0, # Cykey style

    'FNUO': KC.LSFT(KC.N1), # Number + vowel mod for shifter numbers (symbols)
    'FNUOO': KC.LSFT(KC.N2),
    'FWNUOO': KC.LSFT(KC.N3),
    'FCWNUOO': KC.LSFT(KC.N4),
    'F4CWNUOO': KC.LSFT(KC.N5),
    'F4UO': KC.LSFT(KC.N6),
    'F4CUO': KC.LSFT(KC.N7),
    'F4CWUO': KC.LSFT(KC.N8),
    'F4CWNUO': KC.LSFT(KC.N9),
    'FWUO': KC.LSFT(KC.N0),
 
    # Better than the asterisk reach? But it's always in use anyway...
    'Hg': OutputStroke(KC.SPC, attach_left = True, attach_right = True),
    
    'F4CN': DVP['COMM'],
    'FCWN': DVP['DOT'],
    'FCWO': DVP['QUES'], # 
    'F4WN': DVP['EXLM'],

    'F4CNO': DVP['COLN'],
    'FCNO': DVP['SCLN'],
    'F4W': KC.LEFT_PAREN, # TODO: bind right (suppress space = set join flag)
    'FWO': KC.RIGHT_PAREN,
    'F4O': KC.QUOT, # DVp['MINUS'], # Don't know why this doesn't work via DV
    'FCW': KC.LSFT(KC.Q), # DOUBLE_QUOTE # TODO: bind right (suppress space)
    'F4WNO': DVP['QUOT'], # TODO: bind right (suppress space)
    # so... 

    'F4WO': DVP['EQL'],
    'FCO': DVP['BSLS'],
    'F4N': DVP['SLSH'],

    # Punctuation up to here should probably be top-layer
    # If I want this for coding all braces and things too
    # Right-hand modifier, left-hand symbol select?
    # RLCT is open... (generates rpt but that's kind of useless)

    # Stolen from Ardux

    'CTrlct': OutputStroke(DVP['EXLM'], attach_left = True, end_sentence = True),
    'TNrlct': OutputStroke(DVP['COMM'], attach_left = True, end_sentence = False),
    'HNrlct': OutputStroke(DVP['DOT'], attach_left = True, end_sentence = True),
    'THNrlct': OutputStroke(DVP['QUOT'], attach_left = True, attach_right = False), # Left single quote
    '4THrlct': OutputStroke(DVP['QUOT'], attach_left = False, attach_right = True), # Right single quote
    'SNrlct': DVP['SLSH'],
    'NRrlct': OutputStroke(KC.LSFT(DVP['QUOT']), attach_left = True, attach_right = False), # Left dquote
    '4Srlct': OutputStroke(KC.LSFT(DVP['QUOT']), attach_left = False, attach_right = True), # Right dquote
    # Apostrophe is STWN, without punctuation modifier (since it joins with other words)

    # R +
    # ` ; \ 
    # = - ? R
    '4Rrlct': KC.GRV,
    'CRrlct': OutputStroke(DVP['SCLN'], attach_left = True),
    'WRrlct': DVP['BSLS'],

    'SRrlct': DVP['EQL'],
    'TRrlct': KC.QUOT, # Still weird (-)
    'HRrlct': OutputStroke(DVP['QUES'], attach_left = True, end_sentence = True),

    # N + (same as above, with shift held
    # ~ : | N
    # X X X  <-- Xs are regular punctuation instead
    '4Nrlct': KC.LSFT(KC.GRV),
    'CNrlct': OutputStroke(KC.LSFT(DVP['SCLN']), attach_left = True),
    'WNrlct': KC.LSFT(DVP['BSLS']),
    #'SNrlct': DVP['EQL'], # already shifted
    #'TNrlct': KC.LSFT(KC.QUOT), # Still weird (-) underscore needs to be moved somewhere...
    #'HNrlct': DVP['QUES'], # already shifted
    # Or don't?
    # TODO: hash and whatever?
    # Need to summarize what I actually need...

    # ARGH these are hold-taps, not just taps...
    # NR +
    # { ( ) N
    # } [ ] R
    '4NRrlct': DVP['SLSH'], # remainder NYI
    'CNRrlct': OutputStroke(KC.LEFT_PAREN, attach_right = True),
    'WNRrlct': OutputStroke(KC.RIGHT_PAREN, attach_left = True),
    'SNRrlct': DVP['SLSH'],
    'TNRrlct': DVP['SLSH'],
    'HNRrlct': DVP['SLSH'],
     # Need to put < > somewhere
        }

class Chord():
    def __init__(self, compact):
        self.compact = compact
        self.chord = {x: False for x in jd_keycodes}

        self.auto_space = True

        # Things that flow into the next chord
        self.next_shift = False
        self.suppress_space = True
        self.last_suppress_space = False
        self.last_stroke = 1 # for backspacing
        self.last_shift = False

    def reset(self):
        for x in self.chord:
            self.chord[x] = False

    def add(self, key):
        self.chord[key] = True
    def discard(self, key):
        self.chord[key] = False

    def result(self):
        blocks = ["".join([c for c in keys if self.chord[c]]) for keys in (center_keycodes, lh_keycodes, rh_keycodes, special_keycodes)]
        combined = blocks[1] + blocks[0] + blocks[2] + blocks[3]

        if len(combined) == 0:
            return ""

        print("Chord: ", blocks)

        join_block = False
        shifted = False
        end_sentence = False
        attach_left = False
        attach_right = False
        end_sentence = False

        output = ""


        if combined == "S" and self.compact or combined == "BS" or combined == "SHIFT":
            result = [KC.BSPACE] * self.last_stroke
            self.last_stroke = 1
            # ARGH need to carry this forward properly...
            self.suppress_space = self.last_suppress_space
            self.last_suppress_space = False

            self.next_shift = self.last_shift
            self.last_shift = False
            return result

        if combined == "rnghts": # -RNGHTS: Enter (-> no space)
            self.last_stroke = 1
            self.suppress_space = True
            return [KC.ENTER]
        elif combined == "STHR": # STHR-: Shift next char
            self.next_shift = True
            return []
        elif combined == "STHRrlct": # STHR-rlct: unshift next char
            self.next_shift = False
            return []
        elif combined == "WHNRrnlg": # WHNR-rnlg (inner 2x2s): Auto space toggle
            self.auto_space = not self.auto_space
            self.suppress_space = True
            return []
        elif combined == "SCTWHN": #SCTWHN: escape
            self.suppress_space = True
            return [KC.ESCAPE]
        elif combined == "SCTWHR": #SCTWHR: tab (the SB combos - SBN, SBR are useless)
            self.suppress_space = True
            return [KC.ESCAPE]
        elif combined == 'rlgcht':  # -rlgcht: Force-suppress next space
            # Normally generates rlft, useless
            # Could also just double-flip space enable
            self.suppress_space = True
            return []
        elif combined in specials:
            # HRM this will require a rework later.
            # For now it's only endings that attach, but there will be full words later
            # should release suppress-space, I guess...?
            # So these should probably generate {^}es and whatever instead

            # If a generated block starts with {^}, do not write out the space even if it's buffered
            # ... ends with {^}, force suppress-space off (wait this makes no sense)
            # What I actually want is... single quote, stick to the trailing part
            # full stop and into the next word is not something I want to do, so the suppression doesn't have to work like that
            # Now that the space is pushed to the next word.... 'attach' is the only thing needed?
            # Not quite. Left paren, right paren and single quote join differently
            # Single quote and apostrophe also generate differently, do they need different rules?
            # Even different strokes?
            # Apostrophe in the main layer might work... but it's a bit complicated
            #self.suppress_space = True
            # HEY WAIT suppress_space here is different to the above
            # it doesn't link to the next cycle!
            #self.next_shift = False
            # Same as the above - forcefully unshift _this_ key
            # TODO: Maybe this wil mess with backspace
            special = specials[combined]
            if isinstance(special, OutputStroke):
                end_sentence = special.end_sentence
                attach_left = special.attach_left
                attach_right = special.attach_right
                if special.ignore_shift:
                    self.next_shift = False

                special = specials[combined].keycode

            if isinstance(special, Key):
                output = [special]
            else:
                output = special
        else:
            # The regular chord generation rules
            generated = []
            output_v = []
            vowel_shift = blocks[0].startswith("UO")
            vrules = rules_vowels_shifted if vowel_shift else rules_vowels
            idx = 2 if vowel_shift else 0
            while idx < len(blocks[0]):
                initial_idx = idx
                if blocks[0][idx] not in vrules:
                    output_v += blocks[0][idx]
                    idx += 1
                    continue
                candidates = vrules[blocks[0][idx]]
                for c in candidates:
                    if blocks[0].startswith(c[0], idx):
                        output_v += list(c[1])
                        idx += len(c[0])
                        break

                # TODO: just to stop the vowels from breaking
                if idx == initial_idx:
                    output_v += blocks[0][idx]
                    idx += 1

            for block in range(1, 4):
                block_output = []
                idx = 0
                while idx < len(blocks[block]):

                    # single x is used for things
                    if blocks[block].startswith(('X', 'z', 'Z'), idx):
                        join_block = True
                        idx += 1
                        continue
                    if blocks[block].startswith('SHIFT', idx):
                        idx += 5 # len('shift')
                        shifted = True
                        break # not continue because SHIFT is at the end

                    initial_idx = idx

                    if blocks[block][idx] not in rules:
                        block_output += list(blocks[block][idx])
                        idx += 1
                        continue

                    candidates = rules[blocks[block][idx]]
                    for c in candidates:
                        if blocks[block].startswith(c[0], idx):
                            block_output += list(c[1])
                            idx += len(c[0])
                            break

                    # Guarantees no infinite loop
                    if idx == initial_idx:
                        block_output += list(blocks[block][idx])
                        idx += 1
                generated.append(block_output)

            output = generated[0] + output_v + generated[1] + generated[2]
            if len(output) == 0: # At current, only space and shift
                if shifted:
                    # this should be unreachable
                    result = [KC.BSPACE] * self.last_stroke
                    self.last_stroke = 1
                    return result
                elif join_block:
                    self.last_stroke = 1
                    self.suppress_space = True
                    return [KC.SPC]
                else:
                    return ""

            # Horrible hack: apostrophe force-attaches (don't want to put it in specials because there are too many RH combos)
            # NOTE: check blocks rather than output for generated auto-spacing, since the null (WHR) generates nothing and then it's empty
            if output[0] == "'" or len(blocks[1]) == 0: # or join_block:
                attach_left = True
                join_block = True

        keystrokes = [c if isinstance(c, Key) else DVP[c] for c in output]

        # The shifted flag is deprecated
        if self.next_shift:
            keystrokes[0] = KC.LSFT(keystrokes[0])
        self.last_shift = self.next_shift
        self.last_suppress_space = self.suppress_space

        if not self.suppress_space and not join_block and not attach_left and self.auto_space:
            keystrokes = [KC.SPC] + keystrokes
        self.last_stroke = len(keystrokes)

        self.next_shift = end_sentence
        self.suppress_space = attach_right
        # Something is wrong here, suppress_space flows into the next block weirdly.
        # Suppress next is bascially now never useful...?
        # Apart from attach_right type punctuation

        return keystrokes

## Compact mode: left S tapped alone is backspace
class Jackdaw(Module):
    CHAINABLE = set(('X', 'Z', 'z', 'F'))
    def __init__(self, compact = False):
        self.chord = Chord(compact)
        self.compact = compact

        self.held = set()
        self.pressing = True # press/release edge

        # Stream the output
        self.send_next = []
        # Try to work around the tap_key weirdness
        self.now_pressed = None

    def process_key(self, keyboard, key, is_pressed, int_coord):

        if not isinstance(key, JackdawKey):
            return key

        # TODO: Can we detect modifiers? Want to force a mode switch to non-spaced if they're held
        # And then maybe a null modifier to unspace might be nice... (fingerspell key)

        code = key.code

        if is_pressed:
            self.held.add(code)
            self.chord.add(code)
            self.pressing = True
        else:
            self.held.discard(code)
            # keys_pressed is the USB report; coordkeys is real keys (kmk internal)
            # Peeking inside chord is terrible
            # TODO: If modifiers are held down, also trigger this
            if self.pressing and (self.held - self.CHAINABLE == set() or self.chord.auto_space == False):
                output = self.chord.result()
                self.handle_output(output)
                self.chord.reset()
                for key in self.held:
                    if self.chord.auto_space == False or key in self.CHAINABLE:
                        self.chord.add(key)
                self.pressing = False
            elif self.chord.auto_space == False:
                self.chord.discard(code)
            # CRAP this logic has gone all wonky
            # If auto-space (rolling mode), execute
            # Otherwise, wait for all keys to be gone
            # was the original intent...

    # Not really chord, this is the output string
    def handle_output(self, chord):
        if chord == "":
            return
        out = [c for c in list(chord)]
        out.reverse()

        self.send_next += out

    def during_bootup(self, keyboard):
        pass

    def before_matrix_scan(self, keyboard):
        pass
    def after_matrix_scan(self, keyboard):
        pass

    def before_hid_send(self, keyboard):
        was_pressed = self.now_pressed 
        if self.now_pressed != None:
            keyboard.remove_key(self.now_pressed)
            self.now_pressed = None
        # up/down in the same frame is possible unless it's the same key
        if len(self.send_next) > 0 and self.send_next[-1] != was_pressed:
            key = self.send_next.pop()
            keyboard.add_key(key)
            self.now_pressed = key

    def after_hid_send(self, keyboard):
        pass

    def on_powersave_enable(self, keyboard):
        pass

    def on_powersave_disable(self, keyboard):
        pass

# In the end this is a lot closer to the original Shelton patent than the Jackdaw theory

# TODO:
# Rolling chords when auto space is disabled
# LEDs to indicate auto space (and other stuf)
# Matrix reset button
# Merge punctuation/number key into one word
#   on press -> emit space
#   at end of word -> re-enable auto space
# A second holdable key to attach the current stroke, rather than the next stroke?
#   Not super useful but handy when there's too much going on to asterisk a stroke properly

# Silliness that may work: anything starting with vowels or RH automatically attaches
# And a null LH combo to start a new word from vowel/right
# Unfortunately that leads to an advantage to overusing the right hand
# Mabye WHNR?
# How much extra asterisking does this save me?

# TODO problem: When turning auto-space back on, the last chord gets spat out again
